# Freezed Implementation Guide

## Overview

This project now uses [Freezed](https://pub.dev/packages/freezed) for generating immutable data classes with automatic implementations of `copyWith`, `==`, `hashCode`, `toString`, and JSON serialization.

## Benefits

### Code Reduction
- **Before**: Manual implementation of ~100+ lines per model
- **After**: ~30-40 lines per model with Freezed annotations
- **Savings**: ~60-70% reduction in boilerplate code

### Automatic Generation
- ✅ `copyWith` methods for immutable updates
- ✅ `==` and `hashCode` for proper equality
- ✅ `toString` for debugging
- ✅ JSON serialization with `json_annotation`
- ✅ Type-safe pattern matching

### Type Safety
- Immutable by default
- Compile-time error checking
- Better null safety integration

## Dependencies Added

### Runtime Dependencies
```yaml
dependencies:
  freezed_annotation: ^2.4.1
  json_annotation: ^4.9.0
```

### Dev Dependencies
```yaml
dev_dependencies:
  build_runner: ^2.4.7
  freezed: ^2.4.6
  json_serializable: ^6.7.1
```

## Configuration

### build.yaml
```yaml
targets:
  $default:
    builders:
      freezed:
        options:
          union_key: type
          copyWith: true
          toString: true
          equal: true
          json: true
      json_serializable:
        options:
          explicit_to_json: true
          include_if_null: false
          checked: true
```

## Usage Examples

### Basic Freezed Class
```dart
import 'package:freezed_annotation/freezed_annotation.dart';

part 'user.freezed.dart';
part 'user.g.dart';

@freezed
class User with _$User {
  const factory User({
    required String id,
    required String email,
    required String firstName,
    required String lastName,
    String? profilePicture,
    @Default(false) bool isEmailVerified,
    required DateTime createdAt,
    DateTime? updatedAt,
  }) = _User;

  factory User.fromJson(Map<String, dynamic> json) => _$UserFromJson(json);
}
```

### Extension Methods
```dart
extension UserX on User {
  String get fullName => '$firstName $lastName';
  
  String get displayName {
    if (lastName.isNotEmpty) {
      return '$firstName ${lastName[0].toUpperCase()}.';
    }
    return firstName;
  }
  
  bool get hasCompleteProfile => 
      firstName.isNotEmpty && 
      lastName.isNotEmpty && 
      email.isNotEmpty;
}
```

### Usage in Code
```dart
// Create user
final user = User(
  id: '1',
  email: 'john@example.com',
  firstName: 'John',
  lastName: 'Doe',
  createdAt: DateTime.now(),
);

// Update user (immutable)
final updatedUser = user.copyWith(
  isEmailVerified: true,
  updatedAt: DateTime.now(),
);

// JSON serialization
final json = user.toJson();
final userFromJson = User.fromJson(json);

// Equality
final sameUser = User(/* same data */);
print(user == sameUser); // true
```

## Code Generation Commands

### Generate Code
```bash
flutter packages pub run build_runner build
```

### Watch for Changes (Development)
```bash
flutter packages pub run build_runner watch
```

### Clean and Rebuild
```bash
flutter packages pub run build_runner build --delete-conflicting-outputs
```

## File Structure

### Generated Files
- `*.freezed.dart` - Freezed generated code
- `*.g.dart` - JSON serialization generated code

### Example Structure
```
lib/features/auth/
├── domain/entities/
│   ├── user_freezed.dart          # Main file
│   ├── user_freezed.freezed.dart  # Generated by Freezed
│   └── user_freezed.g.dart        # Generated by json_serializable
└── data/models/
    ├── user_model_freezed.dart    # Main file
    ├── user_model_freezed.freezed.dart  # Generated
    └── user_model_freezed.g.dart  # Generated
```

## Migration Guide

### Step 1: Add Dependencies
Add Freezed dependencies to `pubspec.yaml` (already done).

### Step 2: Create Freezed Version
1. Create new file with `_freezed.dart` suffix
2. Add Freezed annotations
3. Add part files for generated code
4. Run code generation

### Step 3: Update Imports
Replace imports from old model to new Freezed model:
```dart
// Before
import 'user.dart';

// After
import 'user_freezed.dart';
```

### Step 4: Test Migration
1. Run existing tests
2. Verify functionality
3. Update any custom logic if needed

### Step 5: Remove Old Files
Once migration is complete and tested:
1. Remove old model files
2. Update all imports
3. Clean up any unused code

## Best Practices

### 1. Use Extensions for Business Logic
```dart
extension UserX on User {
  bool get isActive => isEmailVerified && isPhoneVerified;
  String get initials => '${firstName[0]}${lastName[0]}';
}
```

### 2. Default Values
```dart
@freezed
class User with _$User {
  const factory User({
    @Default(false) bool isEmailVerified,
    @Default([]) List<String> tags,
    @Default(UserRole.user) UserRole role,
  }) = _User;
}
```

### 3. JSON Field Mapping
```dart
@freezed
class User with _$User {
  const factory User({
    @JsonKey(name: 'user_id') required String id,
    @JsonKey(name: 'email_address') required String email,
    @JsonKey(includeFromJson: false) String? computedField,
  }) = _User;
}
```

### 4. Union Types for Complex States
```dart
@freezed
class AuthState with _$AuthState {
  const factory AuthState.initial() = _Initial;
  const factory AuthState.loading() = _Loading;
  const factory AuthState.authenticated(User user) = _Authenticated;
  const factory AuthState.unauthenticated() = _Unauthenticated;
  const factory AuthState.error(String message) = _Error;
}
```

## Testing

### Unit Tests
```dart
test('User copyWith functionality', () {
  final user = User(/* ... */);
  final updated = user.copyWith(isEmailVerified: true);
  
  expect(updated.isEmailVerified, true);
  expect(updated.id, user.id); // Other fields unchanged
});

test('User JSON serialization', () {
  final user = User(/* ... */);
  final json = user.toJson();
  final userFromJson = User.fromJson(json);
  
  expect(userFromJson, equals(user));
});
```

## Troubleshooting

### Common Issues

1. **Build Runner Fails**
   ```bash
   flutter clean
   flutter pub get
   flutter packages pub run build_runner build --delete-conflicting-outputs
   ```

2. **Import Errors**
   - Ensure part files are correctly referenced
   - Check that generated files exist
   - Run code generation after changes

3. **JSON Serialization Issues**
   - Check field names match JSON keys
   - Use `@JsonKey` for custom mapping
   - Ensure all required fields are provided

### Performance Considerations

- Generated code is optimized for performance
- No runtime reflection used
- Compile-time type checking
- Minimal memory overhead

## Next Steps

1. **Migrate Existing Models**: Convert other models to use Freezed
2. **Add Union Types**: Use for error states and complex data structures
3. **Update Tests**: Ensure all tests pass with new models
4. **Documentation**: Update API documentation to reflect changes

## Resources

- [Freezed Documentation](https://pub.dev/packages/freezed)
- [JSON Annotation Documentation](https://pub.dev/packages/json_annotation)
- [Build Runner Documentation](https://pub.dev/packages/build_runner)
- [Freezed Examples](https://github.com/rrousselGit/freezed/tree/master/packages/freezed/example)
